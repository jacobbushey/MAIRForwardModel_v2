from pyhull.delaunay import DelaunayTri
import numpy as np
from numba import jit
import shapely


SIMPLEX_NOT_FOUND_VALUE = int(-1)
COORD_UNDEFINED_VALUE = -1e20


def triangulate(points: np.ndarray) -> DelaunayTri:
    """
    Compute the Delaunay triangulation of a set of points

    Inputs:
    points: (n, 2) ndarray of points in a 2D cartesian coordinate system.

    Outputs:
    tri: DelaunayTri triangulation of the points. Generated by `pyhull`. See docs here:
        https://pythonhosted.org/pyhull/pyhull.html#module-pyhull.delaunay
        Quick tour:
        `tri.vertices`: (s, 3) [int], for each simplex, the 3 indices in `points` of the simplex's
            vertices.
        `tri.simplices`: (s,) pyhull.Simplex object for each simplex. Methods/properties:
            - `coords`: coordinates of each of the 3 points
            - `bary_coords()`: barycentric coordinates of a user-provided point
            - `in_simplex()`: predicate for a user-provided point
            See https://pythonhosted.org/pyhull/pyhull.html#module-pyhull.simplex
    """
    MIN_POINTS_FOR_TRIANGULATION = 4  # a requirement of `pyhull`

    if points.shape[0] < MIN_POINTS_FOR_TRIANGULATION:
        raise ValueError("Too few points to triangulate")

    if points.shape[1] != 2:
        raise ValueError(f"Must be 2D points, but points were {points.shape[1]}D")

    return DelaunayTri(points)


@jit(nopython=True)
def _find_first_simplex(
    point_coords: np.ndarray,
    strtree_query_results: tuple[np.ndarray, np.ndarray],
    simplex_origins: np.ndarray,
    T_invs: np.ndarray,
) -> tuple[np.ndarray, np.ndarray]:
    """
    This is a utility function called by `simplex_info_for_points()`. It takes:

    - `point_coords`: A set of points
    - `strtree_query_results`: The result of an STRTree query, which identifies simplices covering
       the points (a many-to-many relationship)
    - `simplex_origins`, `T_invs`: Information from `pyhull` that is specific to each simplex, and
      needed to determine the barycentric coordinates of any points lying within these simplices.

    For each point, this function identifies the first covering simplex in the portion of the
    STRTree results that concerns the point. For each point, it returns the index of the covering
    simplex, and the barycentric coordinates of the point within that same simplex.

    Inputs:
    point_coords:
        (n,2) [float] XY coordinates of each point
    strtree_query_results: tuple[q_points, q_simplices]:
        Both are (q,) [int]
        The return value of `shapely.STRTree.query()`, where:
        - `q_point[i]` is the index of a point in the LHS of the query
        - `q_simplices[i]` is the index of a simplex polygon that matched the query's predicate,
          from the RHS of the query.
    simplex_origins:
        (m,) [float]
        Arbitrary vertex chosen by `pyhull` as the origin of each of the `m` simplices
    T_invs:
        (m,) [float]
        T_inv for each simplex, a property determined by `pyhull`

    Outputs:
    simplex_indices_for_points: (n,) [int]
        Index of the first simplex encountered that covers point `i`, for all `i` in `n` points.
    barycentric_coords_of_points: (n, 3) [float]
        Barycentric coordinates within that covering simplex for each point `i`, for all `i` in `n`
        points.
    """
    TOLERANCE = 1e-8
    q_points, q_simplices = strtree_query_results
    n = point_coords.shape[0]
    q = q_points.shape[0]

    simplex_indices_for_points = np.full((n,), SIMPLEX_NOT_FOUND_VALUE, dtype=np.uint32)
    barycentric_coords_of_points = np.full((n, 3), COORD_UNDEFINED_VALUE)

    # (q, 2)
    c = np.empty((q, 2))
    for i in range(q):
        # In normal numpy, you can do this using `np.dot` without using a for loop, but the
        # necessary overload is not supported by Numba. Falling back to a for loop in Numba is not a
        # big deal, though.
        c[i] = np.dot(
            point_coords[q_points[i]] - simplex_origins[q_simplices[i]],
            T_invs[q_simplices[i]],
        )

    # (q, 3)
    bary_coords = np.column_stack((c, 1 - np.sum(c, axis=1)))

    # If any coordinate in a set of 3 barycentric coordinates is below 0, then the point that the
    # coordinates describe lies outside the simplex.
    #
    # (q,) dtype=bool
    in_simplex = np.sum(bary_coords >= -1 * TOLERANCE, axis=1) == 3

    skip_this_point = -1
    for i in range(q):
        if q_points[i] != skip_this_point and in_simplex[i]:
            # We've found a simplex for this point: write that down, and write down the barycentric
            # coordinates of the point within this simplex.
            simplex_indices_for_points[q_points[i]] = q_simplices[i]
            barycentric_coords_of_points[q_points[i]] = bary_coords[i]

            # Skip this point if we see it again.
            # Note: `q_points` is in sorted order (ascending point index)
            skip_this_point = q_points[i]

    return simplex_indices_for_points, barycentric_coords_of_points


def simplex_info_for_points(
    point_coords: np.ndarray, tri: DelaunayTri
) -> tuple[np.ndarray, np.ndarray]:
    """
    For a set of 2D points `points` that lies within a triangulation `tri`, compute:
    - The index of the simplex in which each point lies
    - The barycentric coordinates of each point, within the simplex in which it lies

    Inputs:
    point_coords: (n,2) [float] ndarray of 2D points
    tri: An instance of pyhull's DelaunayTri class. All points in `point_coords` must lie within the
        triangulation. Obtain this by calling `triangulate()`.

    Outputs:
    simplex_indices_for_points:
        np.ndarray[int] (n,), the index of the simplex that contains the point, for
            every point `i` in `n`.

    barycentric_coords_of_points:
        np.ndarray[float] (n, 3), the 3 barycentric coordinates that define each point's position
            within its enclosing simplex, for every point `i` in `n`.

    An error will be thrown if a simplex could not be identified for a point.
    """
    n = point_coords.shape[0]
    barycentric_coords_of_points = np.full((n, 3), COORD_UNDEFINED_VALUE)

    # Build Shapely polygons of each simplex. We need to do this because that's what STRTree accepts
    # as input. These polygons aren't used anywhere else.
    #
    # return type: npt.NDArray[Polygon]
    simplex_polygons = shapely.polygons(
        [tri.points[three_indices] for three_indices in tri.vertices]
    )

    # tuple[(q,), (q,)], where `q` = the number of results returned by the spatial index query
    #
    # See docs on `shapely.STRtree.query`, but one array is indices of points, and the other array
    # is indices of matched simplices. I.e., x[0] is the index of a point, y[0] is the index of a
    # simplex that covers the point.
    #
    # "covered by" predicate: means "inside or on the border of" in Shapely-world
    strtree_query_results = shapely.STRtree(simplex_polygons).query(
        shapely.points(point_coords), predicate="covered_by"
    )

    # Check to make sure we found at least 1 match for every point we queried
    if set(range(n)) != set(strtree_query_results[0]):
        missing_points = set(range(n)) - set(strtree_query_results[0])
        raise ValueError(f"STRTree query failed for find a simplex for points {missing_points}")

    # Note: the following approach to finding barycentric coords and determining whether a point is
    # in a simplex is adapted from the (too-slow) implementation of the same functionality in the
    # `pyhull` library:
    #
    # https://github.com/materialsvirtuallab/pyhull/blob/4d9d908915adfe0426e47ff569e06d1ba44d55d0/pyhull/simplex.py#L57-L80

    # 2D coordinates of an arbitrary "origin" vertex on each simplex
    # (m, 2)
    simplex_origins = np.stack([simplex.origin for simplex in tri.simplices])

    # T_invs: a transformation matrix for each simplex
    # (m, 2, 2)
    T_invs = np.stack([simplex.T_inv for simplex in tri.simplices])

    # Call into fast routine to find the first simplex that contains each point. This is necessary
    # because STRTree does not guarantee that we identify only one simplex for each point, and
    # STRTree does not allow for as precise a treatment of tolerance in the way that
    # `_find_first_simplex()` does.
    (
        simplex_indices_for_points,
        barycentric_coords_of_points,
    ) = _find_first_simplex(
        point_coords=point_coords,
        strtree_query_results=strtree_query_results,
        simplex_origins=simplex_origins,
        T_invs=T_invs,
    )

    if (simplex_indices_for_points == SIMPLEX_NOT_FOUND_VALUE).any():
        missing_points = np.where(simplex_indices_for_points == SIMPLEX_NOT_FOUND_VALUE)[0]
        raise ValueError(f"Could not identify some simplex for a points {missing_points}")

    return simplex_indices_for_points, barycentric_coords_of_points
